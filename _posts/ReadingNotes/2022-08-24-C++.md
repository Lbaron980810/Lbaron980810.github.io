---
title: C++ 基础
tags: C++
category: ReadingNotes
---

# C++ 基础

## C++三大特性

1. 继承

定义：让某种类型对象获得另一个类型对象的属性和方法

功能：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展

常见的继承方式：

- 实现继承：指使用积累的属性和方法无需额外编码的能力
- 接口继承：指仅使用属性和方法的名称，但是子类必须提供实现的能力
- 可视继承：指子类使用基类的外观和实现代码的能力

2. 封装

定义：将数据和代码捆绑在一起，避免外界干扰和不确定访问

功能：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏

3. 多态

定义：对同一事物表现出不同事物的能力，即想不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）

功能：多态性是允许你将父对象设置为和其子对象相等的技术，赋值之后，父对象就可以根据当前赋值给他的子对象的特性以不同的方式运作（即允许将子类类型的指针赋值给父类类型的指针 , (parent \*) p = (child \*) c）

实现多态的两种方式：

- 覆盖：指子类重新定义父类的虚函数
- 重载：指允许存在多个同名函数，但函数的参数表不同



## 虚函数

当基类希望派生类定义适合自己的版本，就将这些函数声明为虚函数

**虚函数依赖虚函数表工作，表来保存虚函数地址，当我们用基类指针指向派生类时，虚表指针指向派生类的虚函数表，这个机制可以保证派生类中的虚函数被调用到**

1. 虚函数是动态绑定的：使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数，这是虚函数的基本功能
2. 多态（不同继承关系的类对象，调用同一函数产生不同行为）

- 调用函数的对象必须是指针或者引用
- 被调用的函数必须是虚函数，且完成了虚函数的重写（派生类中有一个跟基类完全相同的虚函数）

3. 动态绑定绑定的是动态类型：所对应的函数或属性依赖于对象的动态类型，发生在运行期
4. **构造函数不能是虚函数**：在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好，多态是被disable的

**构造函数不能定义为虚函数**。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。虚函数对应一个 vtable (虚函数表)，类中存储一个 vptr 指向这个 vtable。如果构造函数是虚函数，就需要通过 vtable 调用，可是对象没有初始化就没有 vptr，无法找到 vtable，所以构造函数不能是虚函数。

5. 虚函数的工作方式

依赖虚函数表工作的，表来保存虚函数地址，当我们用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表。这个机制可以保证派生类中的虚函数被调用到

6. 析构函数可以是虚函数，而且在一个复杂类机构中往往是必须的

为什么父类的析构函数必须是虚函数？如果析构函数不声明为虚函数，那么编译器将实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不会调用派生类的析构函数。这样就会造成内存泄漏

7. inline, static都不能带有virtual关键字

- inline在编译时展开，必须有实体
- static成员没有this指针，而虚函数一定要通过对象来调用，有隐藏的this指针，是实例相关的

8. 析构函数可以使纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的
9. 派生类的虚函数定义必须和父类完全一致，除非父类中返回值是一个指针或引用，子类override时可以返回这个指针或引用的派生

## 为什么需要虚继承

1. 为了解决多继承时命名冲突和冗余数据问题C++提出了虚继承，使得在派生类中值保留一份间接基类的成员
2. 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类







## 其他

1. 在main执行之前和之后执行的代码可能是什么？

在main之前：主要是初始化系统相关资源

- 设置栈指针
- 初始化static变量和global全局变量，即.data段的内容
- 将未初始化部分的全局变量赋初值，即.bss段的内容
- 全局对象初始化，在main之前调用构造函数
- 将main函数的参数argc, argv等传递给main函数，然后才真正运行mian函数

在main之后：

- 全局对象的析构函数
- 可以用atexit注册一个函数，会在main之后执行



2. 结构内存对齐问题

- 结构体内成员按照声明顺序存储，第一个成员地址和结构体地址相同
- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）
- c++ 11以后引入的两个关键字alignas与alignof中，alignof可以计算出类型的对齐方式，alignas可以指出结构体的对齐方式
- 若alignas指定的数值小于自然对齐最小的单位，则被忽略



3. 指针和引用的区别

- 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是一个东西，是原变量的别名
- 指针可以有多级，引用只有一级
- 指针可以为空，引用不能为NULL且在定义时必须初始化
- 指针在初始化之后可以改变指向，而引用在初始化之后不可再改变
- sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量不影响实参，而引用可以。
- 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间



4. 在传递函数参数时，什么时候用指针什么时候用引用？

- 需要返回函数内局部变量的内存时用指针
- 对栈空间大小比较敏感的时候用引用
- 类对象作为参数传递的时候用引用，这是C++类对象传递的标准方式



5. 堆和栈的区别

- 申请方式不同，栈由系统自动分配，堆是自己申请和释放的
- 申请大小限制不同
  - 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定
  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整
- 申请效率不同
  - 栈由系统分配，速度快，不会有碎片
  - 堆由程序员分配，速度慢，会有碎片



6. new/delete 与 malloc/free的异同

相同点：

- 都可用于内存的动态申请和释放

不同点：

- 前者是C++关键字，后者是C/C++语言标准库函数
- new自动计算要分配的空间大小，malloc需要手动计算
- new是类型安全的，malloc不是
- new和delete会分配空间并调用相关的构造函数和析构函数，后者不会
- 后者需要库文件支持，前者不用
- new封装了malloc，直接free不会报错，但只释放内存，不会析构对象
- new和delete是运算符，不重载；malloc和free是标准库函数，支持覆盖
- new和delete返回具体类型指针，malloc和free返回void类型指针



7. new和delete是如何实现的

- new的实现过程：先调用名为operator new的标准库函数，分配足够大的内存，接下来运行构造函数，最后返回指向新分配并构造后的对象的指针
- delete的实现过程：对指针指向的对象运行适当的析构函数，然后调用名为operator delete的标注库函数释放该对象所用内存



8. 既然有了malloc/free，为什么还需要new/delete

- 非基本数据类型的对象使用的时候，需要执行构造函数和析构函数。malloc和free是库函数，已经编译过了，不能把构造函数和析构函数的功能强加给malloc和free



9. 被free回收的内存是立即返划给操作系统吗？

- 不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占据过多的系统资源，同事ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。



10. 宏定义和函数有何区别？

- 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数
- 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值
- 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查
- 宏定义不要在最后加分号



11. 宏定义和typedef的区别？

- 宏定义主要用于定义常量和书写复杂的内容；typedef主要用于定义类型别名
- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分
- 宏不检查类型；typedef会检查数据类型
- 宏不是语句，不用在最后加分号；typedef是语句，需要加分号
- 对指针的操作差别巨大？？？



12. 变量声明和定义的区别

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义会分配内存空间
- 相同变量可以在多处声明，但只能在一处定义



13. strlen和sizeof的区别

- sizeof是运算符，不是函数，结果在编译时得到；strlen是字符处理的库函数
- sizeof的参数可以是任何数据类型或者数据；strlen的参数只能是字符串



14. 常量指针和指针常量的区别？

- 指针常量是一个指针，即常量的指针，指向一个只读变量，写作int const *p, const int *p
- 常量指针是一个不能改变指向的指针。指针是一个常量，写作int * const p



15. C++中struct和class的区别

相同点：

- 两者都拥有成员函数、公有和私有部分
- 任何可以使用class完成的工作，同样可以使用struct完成

不同点：

- struct默认公有，class默认私有
- struct默认public继承，class默认private继承



16. define和const的区别

- define是在编译的预处理阶段起作用，属于文本插入替换；const是在编译、运行的时候起作用

- 安全性：
  - define只做替换，不做类型检查和计算，也不求解，容易产生错误
  - const有数据类型，编译器可以进行安全检查
- 内存占用：
  - define只是将宏名称进行替换，在内存中会产生多份相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放入常量表
  - 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间



17. C++中const和static的作用

static：

- 不考虑类的情况
  - 不加static和全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
  - 默认初始化为0，包括未初始化的全局静态变量和局部静态变量，都存在于全局未初始化区
  - 静态变量在函数内定义，始终存在，且只进行一次初始化，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用
- 考虑类的情况
  - static成员变量：只与类关联，不与对象关联，定义时要分配空间，不能再类声明中初始化，必须在类定义体外部初始化，初始化时不需要标记为static，可以被非static成员函数任意访问。
  - static成员函数：不具有this指针，无法访问累对象的非static成员变量和非static成员函数，不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问

const：

- 不考虑类的情况：
  - const常量在定义时必须初始化，之后无法更改
  - const形参可以接收const和非const类型的实参
- 考虑类的情况：
  - const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能再类中声明时初始化
  - const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable数据的值



18. C++的顶层const和底层const

顶层const：指const修饰的变量本身是一个常量，无法修改

底层const：指const修饰的变量所指的对象是一个常量

```cpp
int a = 10; 
int* const b1 = &a; //顶层const，b1是一个常量
const int* b2 = &a; //底层const，不可以*b = 20这样改变a的值，但是a自己可以变
const int b3 = 20; //顶层const，b3是常量
const int* const b4 = &a; // 前一个const底层，后一个为顶层，b4不可变
const int& b5 = a //用于声明引用变量，底层const
// 以上几种情况，a都是可以改变的，不是const
```

区分作用：

- 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const
- 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const



19. 数组名和指向数组首元素的指针的区别

- 二者均可以通过增减偏移量来访问数组中的元素
- 数组名不是真正意义上的指针，可以理解为常指针，所以没有自增自减的操作
- 当数组名当做形参传递给函数后，就退化成了一般指针，多了自增自减的操作，但sizeof运算符不能再得到原数组的大小了。



20. final和override关键字

- override：当父类中使用了虚函数，在子类中需要对虚函数进行重写，如果不用override的话，函数名写错了就会成为新的函数，而不会被编译器检测到错误
- final：当不希望某个函数被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写会报错



21. 拷贝初始化和直接初始化

- 当用于类类型对象时：**直接初始化调用与实参匹配的构造函数，拷贝初始化调用拷贝构造函数。**拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个对象拷贝到正在创建的对象。
- 注意当用explicit修饰构造函数时，如果构造函数存在隐式转换，编译时会报错



22. 拷贝构造（拷贝初始化）和赋值的区别

- 对于简单类型来说，拷贝初始化和赋值没什么区别
- 对于类和复杂数据类型来说区别则比较大，一个形如`A a = b;`调用拷贝构造函数，一个形如`A a; a = b;`，结果取决于类重载的'='操作符函数



23. extern"C"的用法

为了能正确地在C++代码中调用C语言的代码：在程序加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译。（只能在.h文件或者cpp文件中使用，而不能在.c文件中使用）



24. 野指针和悬空指针

都是指向无效内存区域的指针，访问行为会导致未定义行为

- 野指针：没有被初始化过的指针
- 悬空指针：指针指向的内存已经被释放了



25. C和C++的类型安全

- 什么是类型安全？

类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于改门编程语言是否提供保障类型安全的机制；有时候也可以形容某个程序，判断的标准在于是否隐含类型错误。

- C的类型安全

C只在局部上下文中表现出类型安全，比如试图从一种结构体指针转换成另一种结构体的指针时，编译器会报告错误，除非使用显式类型转换。printf和malloc是两个不安全的例子。malloc返回void*类型指针，做显式转换的时候编译器不会提示错误

- C++的类型安全

C++比C提供更多的机制保障类型安全：

1. 操作符new返回类型指针，而不是void*
2. C++模板函数支持类型检查
3. 引入const关键字代替#define，const是有类型，有作用域的；而#define只是简单的文本替换
4. 一些#define宏可被改写为inline函数，结合重载，可以在类型安全的前提下支持多种类型
5. C++提供dynamic_cast关键字，使转换过程更加安全



26. C++中重载、重写(覆盖)与隐藏的区别

- 重载：同一范围定义中的同名成员函数，参数类型和数目不同，与是否为虚函数无关。
- 重写：派生类覆盖基类中的同名虚函数，且参数个数、参数类型、返回值类型**全部相同**
- 隐藏：派生类屏蔽了基类的同名函数
  - 与基类函数参数相同，但基类函数不是虚函数（区别于重写）
  - 与基类函数参数名不同，无论是否为虚基类函数都会被隐藏（与重载的区别在于两函数不在同一类中）



27. C++有哪几种构造函数

- 默认构造函数（没有参数）
- 初始化构造函数（有参数）
- 拷贝构造函数（参数为该类本身）
- 移动构造函数（move和右值引用，主要区别于拷贝构造，移动构造不需要生成临时变量）
- 委托构造函数（使用他所属类的其它构造函数执行自己的初始化过程）
- 转换构造函数（形参是其他类型变量，且只有一个形参，即隐式转换其他类型为本类型对象）



28. 浅拷贝与深拷贝

- 浅拷贝：只拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针资源就会出现错误
- 深拷贝：不仅拷贝值，还开辟出一块新的空间用来存放新值，即使原来的对象析构、释放内存了也不会影响到深拷贝的值。在实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。

举例：

```cpp
string a = b; // 浅拷贝
string a = new char(2); // 深拷贝
memcpy(a, b, strlen(b));

```



28. 内联函数与宏定义的区别

- 内联函数有参数类型检查，有返回值，可以重载
- 宏定义容易出现歧义
- 使用宏定义的地方都可以使用inline函数
- 作为类成员接口函数来读写类的私有成员或保护成员，会提高效率



29. public, protected, private 访问、继承

- 访问：
  - public变量、成员函数：类的内部外部均可访问
  - protected：类和派生类中访问
  - private：类内访问
- 继承：（派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员）
  - private成员：任意继承时派生类都不可见
  - protected，public成员：派生类中的权限取决于**继承和基类**的权限中更严格那个，举例：protected继承，基类中的public成员，在派生类中为protected；private继承，类中的protected成员，在派生类中为private



30. 大小端存储

- 大端存储：字数据的高字节存储在低地址中
- 小端存储：字数据的低字节存储在低地址中

举例：

0x12345678

小端模式：0x4000 : 0x78, 0x4001: 0x56, 0x4002: 0x34, 0x4003: 0x12

大端模式：0x4000 : 0x12, 0x4001: 0x34, 0x4002: 0x56, 0x4003: 0x78



31. volatile、mutable和explicit关键字的用法

- volatile:
  - volatile是一种类型修饰符，表示变量可以被某些编译器未知的因素更改。volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中几个任务共享的变量需要定义为volatile类型
  - volatile指针：与const指针与指针常量类似。
- mutable：
  - 用于突破const的限制，主要用于const函数中，希望改变某些变量
- explicit：
  - 用于修饰累的构造函数，explicit构造函数不能发生相应的隐式类型转换，只能以显式的方式进行类型转换。
  - 注意：explicit只能用于类内部的构造函数声明；只作用于单个参数的构造函数



32. 什么情况下会调用拷贝构造函数

- 用类的一个实例化对象去初始化另一个对象的时候
- 函数的参数是类的对象时（非引用传递）
- 函数的返回值是函数体内局部对象的类的对象时



33. C++有几种类型的new

- plain new
- nothrow new
- placement new



34. C++处理异常的方法 （对应原42）



35. static的用法和作用

- 作用1：隐藏——当同时编译多个文件时，所有未加static前缀的全局变量和函数都有全局可见性
- 作用2：保持变量内容的持久。静态数据区的变量（静态变量和全局变量）会在程序刚开始就完成初始化
- 作用3：默认初始化为0（静态数据区的所有变量都初始化为0）
- 作用4：类成员声明为static

static类对象必须要在类外进行初始化；

static类对象没有this指针；

static成员函数不能被virtual修饰；



36. 值传递，指针传递，引用传递的区别和效率

- 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，或是大的结构体对象，将耗费一定的时间和空间
- 指针传递：同样有拷贝数据的过程，但拷贝的是固定长度的地址，本质还是值传递
- 引用传递：传递变量本身，相当于是一个别名
- 指针传递和引用传递的效率比值传递高，一般用引用传递



37. 类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？

- 有赋值初始化和列表初始化：
  - 赋值初始化是在函数体内初始化，先分配内存再赋值
  - 列表初始化是在分配内存空间后，进入函数体之前就赋值
- 派生类的构造函数执行顺序：
  - 虚拟基类的构造函数
  - 基类的构造函数
  - 类类型的成员对象的构造函数
  - 派生类自己的构造函数
- 对于类成员变量，进入构造函数之前会先调用一次默认构造函数。如果在构造函数体内赋值，等于一次默认构造加一次赋值，而初始化类别则直接调用对应的构造函数，只有一次赋值操作



38. 哪些情况必须用到成员列表初始化？

- 初始化引用成员
- 初始化常量成员
- 调用基类构造函数，它拥有一组参数
- 调用一个成员类的构造函数，它有用一组参数



39. C++ 中的string 与 C中的char *的区别

- string继承自basic_string，其实是对char *进行了封装，封装的string包含了char *数组，容量，长度等属性
- string可以动态扩展



40. C++的四种强制转换

- reinterpret_cast：类型之间的强制转换

- const_cast：修改类型的const或者volatile属性，一般用于修改底层指针
- static_cast：转换类型，但没有运行时类型检查来保证转换的安全性
- dynamic_cast：转换类型，有类型检查。（将派生类转换为基类时，dynamic和static的效果是一样的；将基类转换为派生类时，dynamic更安全，即如果转换不安全的话会返回空指针）



41. 有没有遇到过coredump error？怎么调试？

coredump是程序由于异常或者bug在运行时异常退出或终止，在一定的条件下生成的一个叫做core的文件，这个文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等。分析这个文件可以定位到程序异常的对应堆栈调用的信息。



42. 如何获得结构成员相对于结构开头的字节偏移量

offsetof(Struct, x);



43. 静态类型和动态类型，静态绑定和动态绑定

静态类型：对象在声明时采用的类型，在编译期已确定

动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的

静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；

动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

非虚函数一般是静态绑定，而虚函数都是动态绑定（实现多态性）



44. 引用是否能实现动态绑定，为什么？

- 引用**可以**实现动态绑定
- 引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其绑定的对象决定要调用哪个函数。只能是虚函数



45. 全局变量和局部变量的区别

- 生命周期不同：全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在
- 使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。
- 全局变量分配在全局数据段，局部变量分配在堆栈中



46. 如何判断两个浮点数是否相等

相减后取绝对值，与预先设定的精度比较



47. 如果想将某个类作为基类，为什么该类必须定义而非声明？

派生类中包含并且可以使用它从基类继承 而来的成员，为了使用这些成员，派生类必须知道他们是什么



48. 继承机制中对象之间如何转换？指针和引用之间如何转换？

派生类转换成基类可以使自动的；基类转换成派生类需要dynamic_cast



49. 函数指针

- 什么是函数指针？

函数指针指向的是特殊的数据类型，函数的类型是由**返回**的数据类型和其**参数列表**共同决定的

一个函数名就是一个指针，指向函数的代码

- 函数指针的声明方法：int (*pf)(const int&, const int&);

- 为什么有函数指针：希望在同一个函数中通过相同的形参在不同的时间使用产生不同的效果
- 赋值方法：指针名 = &函数名



















# Bottom
